/***************************************************************************************************
Purpose: Define classes/defs/types used by (most) modules
***************************************************************************************************/
#pragma once
#include <iostream>
#include <vector>
#include <stdarg.h> //SYS printing
#include <sys/timeb.h> //Timing

/***************************************************************************************************
										Defines/Typedefs
***************************************************************************************************/

#define PROG_MAX_LEN	128
#define KEY_MAX_LEN		64
#define TEXT_MAX_LEN	64
#define LINES_MAX_CNT	1024

#define DEPTH_MAX	1024 //FIXME!!! this needs to be dynamic. Used for the tab string

#define _STRINGIFY(X) #X
#define STRINGIFY(X) _STRINGIFY(X)

/* Assert used for a user mistake in his program */
#define ASSERT(cond, ...) \
	do { \
		if(!(cond))\
			Error(__VA_ARGS__);\
	} while(0)

// User error; error if cond is true
#define ASSERT_FALSE(cond, ...) ASSERT(!(cond), __VA_ARGS__)

// User error; warn if cond is true
#define ASSERT_WARN(cond, ...) \
	do {\
		if(!(cond)) \
			Warning(__VA_ARGS__);\
	} while(0)

/* Assert used for situations which should never arise, i.e. bugs */
#define INTERNAL_ASSERT(cond, ...) \
	do { \
		if(!(cond))\
			Error("INTERNAL ERROR|" __FUNCTION__ "|" STRINGIFY(__LINE__) "|" __VA_ARGS__); \
	} while(0)

			//Error("INTERNAL_ERROR|" fmt, __VA_ARGS__); \
//same as in consoleapi2.h - don't want to include this in every file
#ifndef FOREGROUND_BLUE
#define FOREGROUND_BLUE      0x0001 // text color contains blue.
#endif
#ifndef FOREGROUND_GREEN
#define FOREGROUND_GREEN     0x0002 // text color contains green.
#endif
#ifndef FOREGROUND_RED
#define FOREGROUND_RED       0x0004 // text color contains red.
#endif
#ifndef FOREGROUND_INTENSITY
#define FOREGROUND_INTENSITY 0x0008 // text color is intensified.
#endif
#ifndef BACKGROUND_BLUE
#define BACKGROUND_BLUE      0x0010 // background color contains blue.
#endif
#ifndef BACKGROUND_GREEN
#define BACKGROUND_GREEN     0x0020 // background color contains green.
#endif
#ifndef BACKGROUND_RED
#define BACKGROUND_RED       0x0040 // background color contains red.
#endif
#ifndef BACKGROUND_INTENSITY
#define BACKGROUND_INTENSITY 0x0080 // background color is intensified.
#endif

enum class CODE
{
	NONE = 0, 

	/*
	* GENERATED BY SCANNING
	*/

	LPAREN, RPAREN, 
	LBRACE, //'['
	RBRACE, //']'
	LBRACKET, //'{'
	RBRACKET,//'}'
	AT, POUND, PERIOD, COMMA, /*CODE_QUOTE_DOUBLE, CODE_QUOTE_SINGLE,*/ SEMICOLON,
	COLON, LARROW, RARROW, EXCLAMATION, AMPERSAND, BAR,
	EQUALS, PLUS, MINUS, STAR, FSLASH, PERCENT,//arithmetic

	//words
	INLINE, SUBR, ANS,
	//data types
	BYTE, WORD, FIXED, LABEL, 
	STRUCT, SIGNED, STATIC, STACK, AUTO,
	//control flow
	REPEAT, UNTIL, WHILE, FOR,
	IF, ELSE, 
	//instructions
	LD, JP, CALL, RET, 
	ADD, SUB, MUL, DIV, MOD, INC, DEC, COMP,
	AND, OR, XOR, NEG,
	RLC, RRC, RL, RR, SL, SR, RES, SET, FLP,
	INN, OT, /* IN & OUT - renamed to get around windows defs */ IM,
	LDM, CPM, INM, OUTM,
	//preprocessing directives
	PP_INCLUDE, PP_INSERT, PP_DEFINE,

	TEXT, NUM_DEC, NUM_BIN, NUM_HEX, NUM_FXD, STRING,

	/*
	* GENERATED BY PARSING
	*/
	
	//TERMINALS
	//these symbols are combinations of reserved chars not caught in lexing. ex. || or even | | will be recognized and turned into a single node in the AST
	//this is due to lazyness when designing the scanner
	T_LOGICAL_OR, T_LOGICAL_AND, T_EQUIVALENCE, T_NON_EQUIVALENCE, T_LESS_OR_EQUAL, T_GREATER_OR_EQUAL, T_DEREF_MEMBER, T_LEFT_SHIFT, T_RIGHT_SHIFT,


	//NON-TERMINALS
	NT_UNIT, NT_EXTERNAL_DECL, NT_FUNC_DEF, NT_FUNC_DECL,
	NT_DECL_SPEC, NT_STORAGE_SPEC, NT_TYPE_SPEC,
	NT_DATA_DECL, NT_SINGLE_DATA_DECL, NT_STRUCT_DECL,
	NT_TYPE_DEF,

	//data
	NT_DATA_TYPE, NT_DATA_MODIFIER,

	//statements
	NT_COMPOUND_STMT, NT_STMT, NT_OPEN_STMT, NT_CLOSED_STMT, NT_SIMPLE_STMT, 
	NT_SELECTION_CLAUSE, NT_WHILE_CLAUSE, NT_FOR_CLAUSE, NT_LABEL_DEF,

	//Instructions
	NT_INSTRUCTION, 
	NT_OPERANDS_ONE, NT_OPERANDS_TWO, NT_OPERANDS_THREE, NT_OPERANDS_ONE_TO_TWO, NT_OPERANDS_ONE_TO_THREE, NT_OPERANDS_TWO_TO_INF, NT_OPERANDS_COMP, NT_OPERANDS_FOUR, NT_OPERANDS_RET, NT_OPERANDS_CALL,

	//misc
	NT_INITIALIZER_LIST,
	NT_PARAMETER, NT_PARAMETER_LIST,
	NT_IDENT,

	//expressions
	//Logical
	NT_LOGICAL_EXPR, 
	NT_OR_EXPR, NT_AND_EXPR, NT_EQUALITY_EXPR, NT_RELATIONAL_EXPR, NT_LOGICAL_POSTFIX_EXPR, NT_LOGICAL_PRIMARY_EXPR,
	//Arithmetic
	NT_ARITHMETIC_EXPR, NT_CONSTANT_EXPR, 
	NT_SHIFT_EXPR, NT_ADDITIVE_EXPR, NT_MULTIPLICATIVE_EXPR, NT_ARITHMETIC_POSTFIX_EXPR, NT_ARITHMETIC_PRIMARY_EXPR, 
	//Memory
	NT_MEMORY_EXPR, NT_MEM_OR_CONST_EXPR, NT_MEMORY_PRIMARY_EXPR

};

typedef struct kv_s
{
	char k[KEY_MAX_LEN] = {};
	CODE v = CODE::NONE;
} kv_t;

const kv_t nullkv = { "NULL", CODE::NONE };

class kv_c
{
private:
	char*	str;
	CODE	code;
public:
	kv_c& operator=(const kv_t& kv);

	inline const char* Str() const { return str; };
	inline CODE Code() const { return code; };

	kv_c& Copy(const kv_c* src);
	void Set(const char* _k, CODE _v);

	kv_c()
	{
		str = NULL;
		code = CODE::NONE;
	}

	kv_c(const char* k, CODE v)
	{
		int cnt;

		for (cnt = 0; k[cnt]; cnt++) {}
		cnt++;

		str = new char[cnt];
		memset(str, 0, cnt * sizeof(char)); //to make sure strcpy works

		strcpy_s(str, cnt, k);
		code = v;
	}

	~kv_c()
	{
		if (str)
			delete[] str;
		str = NULL;
	}
};

class tree_c
{
private:
	bool leaf;
	kv_c kv;
	std::vector<tree_c*> children;

	void R_Disp();
	tree_c* _InsL(tree_c* t);
	tree_c* _InsR(tree_c* t);
public:

	//need to have copies of these for a kv_c* and a const char/int pair
	tree_c* InsR(kv_c* _kv);
	tree_c* InsR(const char* str, CODE code);
	tree_c* InsR(kv_t _kv);
	tree_c* InsL(kv_c* _kv);
	tree_c* InsL(const char* str, CODE code);
	tree_c* InsL(kv_t _kv);
	void	Ins(kv_t _kv, int idx); //needs work. Currently will only add a child if the list is not empty
	tree_c* Ins(const char* str, CODE code, int idx);
	tree_c* Ins(tree_c* t, int idx);

	tree_c* Save(); //make copy of current sub-tree
	void Restore(tree_c* saved);

	void Delete(); //Delete this sub-tree, including the root
	void KillAllChildren(); //Delete this sub-tree, minus the root
	bool KillChild(tree_c* removee); //Delete a single node. Must be called from an ancestor node
	void DetachChild(tree_c* removee); //Get a node out of the list, but don't delete it

	//Getting children
	tree_c* GetL();
	tree_c* GetR();
	tree_c* Get(int idx) const; //rename this

	int GetIndex(tree_c* child); //-1 if non-existant

	void Set(const kv_c* _kv) { kv.Copy(_kv); }
	void Set(const char* str, CODE code) { kv.Set(str, code); }
	const kv_c* Hash() const	{ return &kv; }
	const char* Str() const		{ return kv.Str(); }
	const CODE Code() const		{ return kv.Code(); }
	 
	bool IsLeaf() const { return leaf; }

	void Disp();

	void Collapse(tree_c* child);

	tree_c()
	{
		kv.kv_c::kv_c();
		leaf = true;
	}
	tree_c(kv_t _kv)
	{
		kv = _kv;
		leaf = true;
	}
	~tree_c()
	{
		kv.~kv_c();
		KillAllChildren();
	}
};

void Warning(const char* msg, ...);
void Error(const char* msg, ...);
void SetOutFlags(unsigned short flags); //same as WORD
void ResetOutFlags();