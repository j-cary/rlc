Reserved words:
start,
subr, rout, ans,
db, dw, ptr, dba, dwa, fxd, lbl, type,
repeat, until, while, for,
//conditional stuff
if, else, 
//instrs
ld, call, ret,
add, sub, mul, div, inc, dec,
and, or, xor, 
//rlc, rrc, rl, rr, sla, sra, sll, srl, res, set, flp
rl, rr, sl, sr, res, set, flp
in, out,
im,
//block instrs
ldm, cpm, inm, outm

Reserved chars:
( ) [ ] { }
# . , " ' ;
= + - * / ^

new bnf:
//
//	MAIN PROG CONTROL
//

<translation_unit> ::= <external_decl>*
<external_decl> ::= <function_decl> | <function_def> | <data_decl> | <type_def>

<function_def> ::= 'subr' <identifier> '(' <parameter_list>+ ')' ';'
<function_decl> ::= 'subr' <identifier> '(' <parameter_list>+ ')' <compound_statement>

<data_decl> ::= <data_type> <single_data_decl> { ',' <single_data_decl> }* ';' |
				<array_data_type> <identifier> '=' '{' <initializer_list> '}' ';' |
				<array_data_type> <identifier> '[' <constant_expression> ']' { '=' '{' <initializer_list> '}' }+ ';'  |
				<unitializeable_data_type> <identifier> ';'
<single_data_decl> ::= <identifier> { '=' <constant_expression> }?

<type_def> ::= 'type' '{' <data_decl>+ '}' <identifier> ';'

//
//	DATA TYPES
//

<unitializeable_data_type> ::= lbl | label
<data_type> ::= fxd | db | dw | ptr | fixed | byte | word | pointer
<array_data_type> ::= dfa | dba | dwa | dpa | fixedarray | bytearray | wordarray | ptrarray

//
//	STATEMENTS
//

<compound_statement> ::= '{' <statement>* '}'

<statement> ::= <open_statement> | <closed_statement>
//at least one if not paired with an else
<open_statement> ::= <selection_clause> <statement>									|
						<selection_clause> <closed_statement> 'else' <open_statement> |
						<while_clause> <open_statement>								|
						<for_clause> <open_statement>
//either no if or an if paired with an else
<closed_statement> ::= <simple_statement>												|
						<selection_clause> <closed_statement> 'else' <closed_statement>	|
						<while_clause> <closed_statement>								|
						<for_clause> <closed_statement>
//Does NOT end with a statement/selection_statement
<simple_statement> ::= 'repeat' <compound_statement> 'until' '(' <expression> ')' ';'	|
						<instr_statement>												|
						<data_decl>														|
						<label_def>														|
						<compound_statement>
<selection_clause> ::= if '(' <expression> ')'
<for_clause> ::= 'for' '(' <instr_statement> { ',' <instr_statement> }* '{' ';'  <logical_expression>  ';' <instr_statement> { ',' <instr_statement> }* '}'? ')'
<while_clause> ::= 'while' '(' <logical_expression> ')'
<label_def> ::= <identifier> ':'


//
//	INSTRUCTIONS
//

<instruction> ::= { <instruction_min1_maxinf> | <i_single> | <i_comp> | <i_min1_max2> | <i_min1_max3> | <i_double> | <i_triple> } ';'

//check this shit ouuut..
<instruction_1_ops>		::= { 'jp' }
							<memory_expression>
<instruction_2_ops>		::= { 'res' | 'set' | 'flp' | 'in' | 'out' }
							<memory_expression> ',' <memory_expression>
<instruction_3_ops>		::= { 'ldm'| 'inm' | 'outm' }
							<memory_expression> ',' <memory_expression> ',' <arithmetic_expression>
<instruction_1to2_ops>	::= { 'rl' | 'rr' }	
							<memory_expression> { ',' <memory_expression> }?
<instruction_1to3_ops>	::= { 'sl' | 'sr' }	
							<memory_expression>  { ',' <boolean_constant>  { ',' <memory_expression> }? }?
<instruction_1toinf_ops>::= { 'ld' | 'add' | 'sub' | 'mult' | 'div' | 'mod' }
							<memory_expression> { ',' <memory_expression> }+
<instruction_comp>		::= 'comp'
							<arithmetic_expression>

add, sub, mult, div, mod :'ld' <logical_unary_expression> { ',' <logical_unary_expression> }+
jp, call, inc, dec, im: 'jp' <logical_unary_expression> 
ret: 'ret' { <logical_unary_expression> }?
comp: 'comp' <mathematical_expression>
rl, rr: 'rl' <logical_unary_expression> { ',' <logical_unary_expression> }?
sl, sr: 'sl' <logical_unary_expression>  { ',' <boolean_constant>  { ',' <logical_unary_expression> }? }?
res, set, flp, in, out: 'res' <logical_unary_expression> ',' <logical_unary_expression>
ldm, inm, outm: 'ldm' <logical_unary_expression> , <logical_unary_expression> , <mathematical_expression> //Do I even want to support this, or should I just make this a constant?


//
//	MISC
//

<initializer_list> ::= <constant_expression> { ',' <constant_expression> }*

<parameter> ::= <data_type> <identifier>			//labels and arrays CANNOT be passed to a function!
<parameter_list> ::= <parameter> { ',' <parameter> }*

<identifier> ::= text
<constant> ::= 


//=========================================================================================================//
//	EXPRESSIONS
//	Used for data decls (constant), conditionals, COMP
//	conditionals need:	logical or/and, equality, relational, logical not/dereference (unary), postfix.
//	decls need:			shift, additive, multiplicative, minus [unary?]
//	COMP needs:			shift, additive, multiplicative, minus [unary?], postfix.
//	
//	Note: An array in a conditional can be indexed with a CONSTANT arithmetic expression
//		
//
//	Order of Operations -
//						Post===Unary=Rel========Equ==AndOr=													//
//		Conditional:	.. . [] & * ! >= <= > < != == && || 
//		Math:			.. . [] & * - % / * - + >> <<														//
//						Post===Unary===Mult=Add=Shift														//
//																											//
// Note: Unary minus, not, dereference, and indirection are all right associative.							//
//==========================================================================================================//

//
//	Conditional Expressions
//

<logical_expression> ::= <or_expression>
<memory_expression> ::= <logical_postfix_expression> //reject the logical not, keep ., .., [], &, *

<or_expression> ::=				<and_expression> { '||' <and_expression> }*
<and_expression> ::=			<equality_expression> { '&&' <equality_expression> }*
<equality_expression> ::=		<relational_expression> { { '==' | '!=' } <relational_expression> }*
<relational_expression> ::=		<logical_postfix_expression> { {'<' | '>' | '<=' | '>=' } <logical_postfix_expression> }*
<logical_postfix_expression> ::=<logical_primary_expression> { { { '.' | '..' } <logical_primary_expression> } | '[' <constant_expression> ']' }*
<logical_primary_expression> ::=<identifier> | <constant> | <string> | '(' <logical_expression> ')' | { '&' | '*' | '!' } <logical_expression>


//
//	Math Expressions
//

<constant_expressions> ::= <shift_expression> // reject variables in semantic checking
<arithmetic_expression> ::= <shift_expression>

<shift_expression> ::=				<additive_expression> { { '<<' | '>>' } <additive_expression> }*
<additive_expression> ::=			<multiplicative_expression> { { '+' | '-' } <multiplicative_expression> }*
<multiplicative_expression> ::=		<arithmetic_postfix_expression> { { '*' | '/' | '%' } <arithmetic_postfix_expression> }*
<arithmetic_postfix_expression> ::=	<arithmetic_primary_expression> 
									{ { { '.' | '..' } <arithmetic_primary_expression> } | '[' <arithmetic_expression> ']' }*
<arithmetic_primary_expression> ::=	<identifier> | <constant> | '(' <arithmetic_expression> ')' | { '&' | '*' | '-' } <arithmetic_expression>

